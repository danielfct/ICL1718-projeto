options {
  STATIC=false;
}

PARSER_BEGIN(Parser)

package parser;
import ast.*;

public class Parser {

}

PARSER_END(Parser)

SKIP :
{
  	" "
	|
	"\t"
	|
	"\r"
}

TOKEN :
{
  	< Num: (["0"-"9"]) + >
  	|
  	< PLUS : "+" >
  	|
  	< MINUS : "-">
  	|
  	< TIMES : "*">
  	|
  	< DIV : "/">
  	|
  	< LPAR : "(" >
  	|
  	< RPAR : ")" >
  	|
  	< TRUE : "true" >
  	|
  	< FALSE : "false" >
  	|
  	< OR : "||" >
  	|
  	< AND : "&&" >
  	|
  	< EQ : "==" >	
 	|
 	< NEQ : "!=" >
 	|
 	< LEQ : "<=" >
  	|
  	< GEQ: ">=" >
  	|
  	< LT : "<" >
  	|
  	< GT : ">" >
  	|
  	< NOT: "!" >
  	|
	< DECL : "decl" >
	|
	< ASSIGN : "=" >
	| 
	< IN : "in" >
	| 
	< END: "end" >
  	|
 	< EOL : "\n" >
  	| 
  	< ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
}

ASTNode Start():
{ ASTNode e; }
{
   	e = Disjunction() <EOL>  { return e; }
}


ASTNode Disjunction(): // D -- > C ( '||' C )*
{ ASTNode e1, e2; }
{
	e1 = Conjunction()
	(
	  	<OR> e2 = Conjunction() { e1 = new ASTOr(e1, e2); }
	)*
	{  return e1; }
}

ASTNode Conjunction(): // C -- > B ('&&' B )*
{  ASTNode e1, e2; }
{
	e1 = BooleanExp()
	(
	  	<AND> e2 = BooleanExp() { e1 = new ASTAnd(e1, e2); }
	)*
	{ return e1; }
}

ASTNode BooleanExp(): // B -- > E ('==' E )* | '!' B
{ ASTNode e1, e2; }
{
  	<NOT> e2 = BooleanExp() { return new ASTNot(e2); }
	| 
	e1 = Exp()
	(
		<EQ> e2 = Exp() { e1 = new ASTEqual(e1, e2); }
	  	|
	  	<NEQ> e2 = Exp() { e1 = new ASTNotEqual(e1, e2); }
	  	|
	  	<LT> e2 = Exp() { e1 = new ASTLesser(e1, e2); }
	  	|
	  	<GT> e2 = Exp() { e1 = new ASTGreater(e1, e2); }
	  	|
	  	<LEQ> e2 = Exp() { e1 = new ASTLesserEq(e1, e2); }
	  	|
	  	<GEQ> e2 = Exp() { e1 = new ASTGreaterEq(e1, e2); }
	)*
	{ return e1; }
}


ASTNode Exp() :
{ ASTNode e1, e2; }
{
   	e1 = Term()
	(
	  	<PLUS> e2 = Term() { e1 = new ASTAdd(e1,e2); }
		|
		<MINUS> e2 = Term() { e1 = new ASTSub(e1,e2); }
    )*
    { return e1; }
}

ASTNode Term() :
{ ASTNode e1, e2; }
{
     e1 = Fact()
     (
       	<TIMES> e2 = Fact() { e1 = new ASTMul(e1,e2); }
     	|
     	<DIV> e2 = Fact() { e1 = new ASTDiv(e1,e2); }
     )*
     { return e1; }
}


ASTNode Fact() :
{ Token x; ASTDecl d; ASTNode e1, e2; }
{
  	<MINUS> e1 = Fact() { return new ASTSub(new ASTNum(0), e1); }
	| 
 	x = <Num> { return new ASTNum(Integer.parseInt(x.image)); }
 	| 
	<DECL> { d = new ASTDecl(); }
		(
	  		x = <ID> <ASSIGN> e1 = Exp() { d.newBinding(x.image, e1); }
		)+
		<IN> e2 = Disjunction() <END> { d.addBody(e2); return d; }
	|
	x = <ID> { return new ASTId(x.image); }
	| 
   	<LPAR> e1 = Conjunction() <RPAR> { return e1; }
	|
	<TRUE> { return new ASTBool(true); }
	|
	<FALSE> { return new ASTBool(false); }
}