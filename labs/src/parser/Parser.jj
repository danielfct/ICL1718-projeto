/*

Start ::= Seq

Seq ::= Assign | Assign ';' Seq

Assign ::= Disjunction | Disjunction ':=' Assign

Disjunction ::= Conjunction | Disjunction '||' Conjunction

Conjunction ::= BooleanExp | Conjunction '&&' BooleanExp

BooleanExp ::= ArithmeticExp | BooleanExp '<' ArithmeticExp | BooleanExp '>' ArithmeticExp |
			   BooleanExp '>=' ArithmeticExp | BooleanExp '<=' ArithmeticExp | BooleanExp '==' ArithmeticExp

ArithmeticExp ::= Term | ArithmeticExp '+' Term | ArithmeticExp '-' Term

Term ::= Fact | Term '*' Fact | Term '/' Fact

Fact ::= id | (...) | var | decl-end | ... | -Fact | *Fact | !BooleanExp

*/



options {
  STATIC=false;
}

PARSER_BEGIN(Parser)

package parser;
import java.util.*;
import ast.*;
import ast.ASTFun.Parameter;
import types.*;


public class Parser {

}

PARSER_END(Parser) 

SKIP :
{
  	" "
	|
	"\t"
	|
	"\r"
	|
	"\n"
}

TOKEN :
{
  	< NUM : (["0"-"9"]) + >
  	|
  	< PLUS : "+" >
  	|
  	< MINUS : "-">
  	|
  	< TIMES : "*">
  	|
  	< DIV : "/">
  	|
  	< LPAR : "(" >
  	|
  	< RPAR : ")" >
  	|
  	< TRUE : "true" >
  	|
  	< FALSE : "false" >
  	|
  	< OR : "||" >
  	|
  	< AND : "&&" >
  	|
  	< COMPARE : "==" >
 	|
 	< NEQ : "!=" >
 	|
 	< LEQ : "<=" >
  	|
  	< GEQ : ">=" >
  	|
  	< LT : "<" >
  	|
  	< GT : ">" >
  	|
  	< NOT : "!" >
  	|
	< DECL : "decl" >
	|
	< EQ : "=" >
	|
	< IN : "in" >
	|
	< END : "end" >
	|
	< EL : ";;" >
	|
	< SEMICOLON : ";" >
	|
	< VAR : "var" >
	|
	< ASSIGN : ":=" >
	|
	< WHILE : "while" >
	|
	< DO : "do" >
	|
	< IF : "if" >
	|
	< THEN : "then" >
	|
	< ELSE : "else" >
	|
	< COMMA : "," >
	|
	< ARROW : "->" >
	|
	< FUN : "fun" >
	|
	< COLON : ":" >
 	|
 	< INT : "int" >
	|
	< BOOL : "bool" >
	|
	< REF : "ref" >
	|
	< FUNT : "funt" >
	|
  	< ID : ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
}

IType Type():
{ IType t; List<IType> types = new ArrayList<IType>(5); }
{
    <INT>
    { return IntType.singleton; }
    | 
    <BOOL>
    { return BoolType.singleton; }
    | 
    <REF> <LPAR> t = Type() <RPAR>
    { return new RefType(t); }
    | 
    <FUNT> <LPAR> (t = Type() { types.add(t); })+ <RPAR>
    { final int size = types.size(); return new FunType(types.subList(0, size-1), types.get(size-1)); }
}

ASTNode Start():
{ ASTNode e; }
{
	e = Seq() <EL>  { return e; }
}

ASTNode Seq():
{ ASTNode e1, e2; }
{
  	// left-associative: Exp() ( < SEMICOLON > Exp() )*
	e1 = Assign()
  	[
  		<SEMICOLON > e2 = Seq() { e1 = new ASTSeq(e1, e2); } 
 	] // right associative tree
  	{ return e1; }
}

ASTNode Assign() :
{ ASTNode e1, e2; }
{
	e1 = Exp()
 	[
  		<ASSIGN > e2 = Assign() { e1 = new ASTAssign(e1, e2); } 
  	]
  	{ return e1; }
}

// Just a wrap up function to make parser more clear
ASTNode Exp() :
{ }
{
	{ return Disjunction(); }
}

ASTNode Disjunction(): // D -- > C ( '||' C )*
{ ASTNode e1, e2; }
{
	e1 = Conjunction()
	(
	  	<OR> e2 = Conjunction() { e1 = new ASTOr(e1, e2); }
	)*
	{  return e1; }
}

ASTNode Conjunction(): // C -- > B ('&&' B )*
{  ASTNode e1, e2; }
{
	e1 = BooleanExp()
	(
	  	<AND> e2 = BooleanExp() { e1 = new ASTAnd(e1, e2); }
	)*
	{ return e1; }
}

ASTNode BooleanExp(): // B --> E ('==' | '!=' | '<' | '>' | '<=' | '>=' E )*
{ ASTNode e1, e2; }
{
	e1 = ArithmeticExp()
	(
		<COMPARE> e2 = ArithmeticExp() { e1 = new ASTEqual(e1, e2); }
	  	|
	  	<NEQ> e2 = ArithmeticExp() { e1 = new ASTNotEqual(e1, e2); }
	  	|
	  	<LT> e2 = ArithmeticExp() { e1 = new ASTLesser(e1, e2); }
	  	|
	  	<GT> e2 = ArithmeticExp() { e1 = new ASTGreater(e1, e2); }
	  	|
	  	<LEQ> e2 = ArithmeticExp() { e1 = new ASTLesserEq(e1, e2); }
	  	|
	  	<GEQ> e2 = ArithmeticExp() { e1 = new ASTGreaterEq(e1, e2); }
	)*
	{ return e1; }
}

ASTNode ArithmeticExp() : // A --> E ('+' | '-' E)*
{ ASTNode e1, e2; }
{
   	e1 = Term()
	(
	  	<PLUS> e2 = Term() { e1 = new ASTAdd(e1,e2); }
		|
		<MINUS> e2 = Term() { e1 = new ASTSub(e1,e2); }
    )*
    { return e1; }
}

ASTNode Term() : // T --> T ('*' | '/' E)*
{ ASTNode e1, e2; }
{
     e1 = Unary()
     (
     	<TIMES> e2 = Unary() { e1 = new ASTMul(e1, e2); }
     	|
     	<DIV> e2 = Unary() { e1 = new ASTDiv(e1, e2); }
     )*
     { return e1; }
}

/*

Unary := C | *U | !U | -U

Call := F | F( '('EL')' )*

EL := [ E (',' E)* ] Expression list

F := ID | Decl .. | Num | (E) | <FUN> (...)* <ARROW> Seq() <END>
								fun x1:T1, x2:T2 - > Exp end
*/


ASTNode Unary() :
/*Unary := C | *U | !U | -U*/
{ ASTNode e; }
{
  	e = Call() 	{ return e; }
	|
  	<MINUS> e = Unary() { return new ASTSub(new ASTNum(0), e); }
	|
	<NOT> e = Unary() { return new ASTNot(e); }
	|
	<TIMES> e = Unary() { return new ASTDeref(e); }
}


ASTNode Call() :
/* F | F( '('EL')' )* */
{ ASTNode e1; List<ASTNode> args; }
{
  	e1 = Fact()
  	(
    	<LPAR> args = Arguments() <RPAR> { e1 = new ASTCall(e1, args); }  	)*
  	{ return e1; }
}

List<ASTNode> Arguments() :
/* [ E(',' E)* ] */
{ 	List<ASTNode> args = new ArrayList<ASTNode>(5); ASTNode e; }
{
// 	[
  		e = Seq() { args.add(e); }
  		(
  	  		<COMMA> e = Seq() { args.add(e); }
  		)*
// 	]
  	{ return args; }
}


ASTNode Fact() :
/*ID | Decl | .. | Num | (E)*/
{ Token x; ASTDecl d; ASTNode e1, e2, e3; List<Parameter> params; }
{
 	x = <ID> { return new ASTId(x.image); }
	|
	<DECL> { d = new ASTDecl(); }
		(
	  		x = <ID> <EQ> e1 = Seq() { d.newBinding(x.image, e1); }
		)+
		<IN> e2 = Seq() <END> { d.addBody(e2); return d; }
	|
   	<LPAR> e1 = Seq() <RPAR> { return e1; }
 	|
	<VAR> <LPAR> e1 = Seq() <RPAR> { return new ASTVar(e1); }
	|
	<WHILE> e1 = Exp() <DO> e2 = Seq() <END> { return new ASTWhile(e1, e2); }
	|
	<IF> e1 = Exp() <THEN> e2 = Seq() <ELSE> e3 = Seq() <END> { return new ASTIfThenElse(e1, e2, e3); }
	|
	<FUN> params = Parameters() <ARROW> e1 = Seq() <END> { return new ASTFun(params, e1); }
	|
	<TRUE> { return new ASTBool(true); }
	|
	<FALSE> { return new ASTBool(false); }
	|
	x = <NUM> { return new ASTNum(Integer.parseInt(x.image)); }
}

List<Parameter> Parameters() :
{ List<Parameter> params = new ArrayList<Parameter>(5); Token x; IType t; }
{
 	[
  		x = <ID> <COLON> t = Type() { params.add(new Parameter(x.image, t)); }
  		(
  	  		<COMMA> x = <ID> <COLON> t = Type() { params.add(new Parameter(x.image, t)); }
  		)*
  	]
  	{ return params; }
}
