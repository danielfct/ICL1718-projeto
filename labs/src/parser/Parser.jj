options {
  STATIC=false;
}

PARSER_BEGIN(Parser)

package parser;
import ast.*;

public class Parser {

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
}

TOKEN :
{
  < Num: (["0"-"9"]) + >
  |
  < PLUS : "+" >
  |
  < MINUS : "-">
  |
  < TIMES : "*">
  |
  < DIV : "/">
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
|
< DECL : "decl" >
| 
< IN : "in" >
| 
< END: "end" >
|
< EL: ";;" >
|
< EQ: "=" >
  |
  < ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
}

ASTNode Start():
{ ASTNode e; }
{
   e = Exp() <EL>  { return e; }
}


/*
ASTNode Start():
{ ASTNode e; }
{
   e = Seq() <EL>  { return e; }
}

ASTNode Seq():
{
  ASTNode e1, e2;
}
{
  // left-associative: Exp() ( < SEMICOLON > Exp() )*
  e1 = Assign()
  	[  
  		<SEMICOLON > e2 = Seq()
  		{ e1 = new ASTSeq(e1,e2);} 
 	] // right associative tree
  {
    return e1;
  }
}

ASTNode Assign() :
{
  ASTNode e1, e2;
}
{
  e1 = Exp()
  	[  
  		<SEMICOLON > e2 = Assign()
  		{ e1 = new ASTAssign(e1,e2);} 
 	] 
  {
    return e1;
  }
}
*/

ASTNode Exp() :
{ ASTNode e1, e2; }
{
   e1 = Term() 
     ( <PLUS> e2 = Term() { e1 = new ASTAdd(e1,e2); }
     | <MINUS> e2 = Term() { e1 = new ASTSub(e1,e2); }
     )*
     { return e1; }
}

ASTNode Term() :
{ ASTNode e1, e2; }
{
     e1 = Fact()
     ( <TIMES> e2 = Fact() { e1 = new ASTMul(e1,e2); }
     | <DIV> e2 = Fact() { e1 = new ASTDiv(e1,e2); }
     )*
     { return e1; }
}

ASTNode Fact() :
{ Token x; ASTDecl e; ASTNode e1, e2;}
{
 	x = <Num>
 {
 	return new ASTNum(Integer.parseInt(x.image));
 }
 | 
   <LPAR> e1 = Exp() <RPAR> { return e1; }
|
< DECL >
    { e = new ASTDecl(); }
	(	  x = <ID > <EQ > e1 = Exp()
	  { e.newBinding(x.image,e1); }
	)+
<IN > e2 = Exp()  <END >
{
 	e.addBody(e2);
  	return e;
}
|
x = < ID > { return new ASTId(x.image); }
/*
|
< VAR > <LPAR > e1 = Exp() <RPAR >
	{ return new ASTVar(e1); }
|
< TIMES > e1 = Fact() 
	{ return new ASTDeref(e1); }
	// must be changed afterwards, unary operators
	// *f() <> (*f)()
	// *a.b == *(a.b)
	// *a.b <> (*a).b
| 
< WHILE > e1 = Exp() < DO > e2 = Exp() < END >
	{
	  return new ASTWhile(e1,e2);
	}
| 
< IF > e1 = Exp() < THEN > e2 = Exp() < ELSE > e3 = Exp() < END >
	{
	  return new ASTIf(e1,e2,e3);
	}
	*/
}





















